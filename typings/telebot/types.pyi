"""
This type stub file was generated by pyright.
"""

from typing import Dict, List, Optional, Union
from abc import ABC

DISABLE_KEYLEN_ERROR = ...
logger = ...
class JsonSerializable:
    """
    Subclasses of this class are guaranteed to be able to be converted to JSON format.
    All subclasses of this class must override to_json.
    """
    def to_json(self):
        """
        Returns a JSON string representation of this class.

        This function must be overridden by subclasses.
        :return: a JSON formatted string.
        """
        ...
    


class Dictionaryable:
    """
    Subclasses of this class are guaranteed to be able to be converted to dictionary.
    All subclasses of this class must override to_dict.
    """
    def to_dict(self):
        """
        Returns a DICT with class field values

        This function must be overridden by subclasses.
        :return: a DICT
        """
        ...
    


class JsonDeserializable:
    """
    Subclasses of this class are guaranteed to be able to be created from a json-style dict or json formatted string.
    All subclasses of this class must override de_json.
    """
    @classmethod
    def de_json(cls, json_string):
        """
        Returns an instance of this class from the given json dict or string.

        This function must be overridden by subclasses.
        :return: an instance of this class created from the given json dict or string.
        """
        ...
    
    @staticmethod
    def check_json(json_type, dict_copy=...): # -> Any:
        """
        Checks whether json_type is a dict or a string. If it is already a dict, it is returned as-is.
        If it is not, it is converted to a dict by means of json.loads(json_type)
        
        :param json_type: input json or parsed dict
        :param dict_copy: if dict is passed and it is changed outside - should be True!
        :return: Dictionary parsed from json or original dict
        """
        ...
    
    def __str__(self) -> str:
        ...
    


class Update(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@Update | None:
        ...
    
    def __init__(self, update_id, message, edited_message, channel_post, edited_channel_post, inline_query, chosen_inline_result, callback_query, shipping_query, pre_checkout_query, poll, poll_answer, my_chat_member, chat_member, chat_join_request) -> None:
        ...
    


class ChatMemberUpdated(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@ChatMemberUpdated | None:
        ...
    
    def __init__(self, chat, from_user, date, old_chat_member, new_chat_member, invite_link=..., **kwargs) -> None:
        ...
    
    @property
    def difference(self) -> Dict[str, List]:
        """
        Get the difference between `old_chat_member` and `new_chat_member`
        as a dict in the following format {'parameter': [old_value, new_value]}
        E.g {'status': ['member', 'kicked'], 'until_date': [None, 1625055092]} 
        """
        ...
    


class ChatJoinRequest(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@ChatJoinRequest | None:
        ...
    
    def __init__(self, chat, from_user, date, bio=..., invite_link=..., **kwargs) -> None:
        ...
    


class WebhookInfo(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@WebhookInfo | None:
        ...
    
    def __init__(self, url, has_custom_certificate, pending_update_count, ip_address=..., last_error_date=..., last_error_message=..., last_synchronization_error_date=..., max_connections=..., allowed_updates=..., **kwargs) -> None:
        ...
    


class User(JsonDeserializable, Dictionaryable, JsonSerializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@User | None:
        ...
    
    def __init__(self, id, is_bot, first_name, last_name=..., username=..., language_code=..., can_join_groups=..., can_read_all_group_messages=..., supports_inline_queries=..., is_premium=..., added_to_attachment_menu=..., **kwargs) -> None:
        ...
    
    @property
    def full_name(self): # -> str:
        ...
    
    def to_json(self): # -> str:
        ...
    
    def to_dict(self): # -> dict[str, int | bool | str]:
        ...
    


class GroupChat(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@GroupChat | None:
        ...
    
    def __init__(self, id, title, **kwargs) -> None:
        ...
    


class Chat(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@Chat | None:
        ...
    
    def __init__(self, id, type, title=..., username=..., first_name=..., last_name=..., photo=..., bio=..., has_private_forwards=..., description=..., invite_link=..., pinned_message=..., permissions=..., slow_mode_delay=..., message_auto_delete_time=..., has_protected_content=..., sticker_set_name=..., can_set_sticker_set=..., linked_chat_id=..., location=..., join_to_send_messages=..., join_by_request=..., **kwargs) -> None:
        ...
    


class MessageID(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@MessageID | None:
        ...
    
    def __init__(self, message_id, **kwargs) -> None:
        ...
    


class WebAppData(JsonDeserializable):
    def __init__(self, data, button_text) -> None:
        ...
    
    def to_dict(self): # -> dict[str, Unknown]:
        ...
    
    @classmethod
    def de_json(cls, json_string): # -> Self@WebAppData | None:
        ...
    


class Message(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string):
        ...
    
    @classmethod
    def parse_chat(cls, chat): # -> GroupChat | User | None:
        ...
    
    @classmethod
    def parse_photo(cls, photo_size_array): # -> list[Unknown]:
        ...
    
    @classmethod
    def parse_entities(cls, message_entity_array): # -> list[Unknown]:
        ...
    
    def __init__(self, message_id, from_user, date, chat, content_type, options, json_string) -> None:
        ...
    
    @property
    def html_text(self): # -> str | None:
        ...
    
    @property
    def html_caption(self): # -> str | None:
        ...
    


class MessageEntity(Dictionaryable, JsonSerializable, JsonDeserializable):
    @staticmethod
    def to_list_of_dicts(entity_list) -> Union[List[Dict], None]:
        ...
    
    @classmethod
    def de_json(cls, json_string): # -> Self@MessageEntity | None:
        ...
    
    def __init__(self, type, offset, length, url=..., user=..., language=..., **kwargs) -> None:
        ...
    
    def to_json(self): # -> str:
        ...
    
    def to_dict(self): # -> dict[str, str | int | User]:
        ...
    


class Dice(JsonSerializable, Dictionaryable, JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@Dice | None:
        ...
    
    def __init__(self, value, emoji, **kwargs) -> None:
        ...
    
    def to_json(self): # -> str:
        ...
    
    def to_dict(self): # -> dict[str, int | str]:
        ...
    


class PhotoSize(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@PhotoSize | None:
        ...
    
    def __init__(self, file_id, file_unique_id, width, height, file_size=..., **kwargs) -> None:
        ...
    


class Audio(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@Audio | None:
        ...
    
    def __init__(self, file_id, file_unique_id, duration, performer=..., title=..., file_name=..., mime_type=..., file_size=..., thumb=..., **kwargs) -> None:
        ...
    


class Voice(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@Voice | None:
        ...
    
    def __init__(self, file_id, file_unique_id, duration, mime_type=..., file_size=..., **kwargs) -> None:
        ...
    


class Document(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@Document | None:
        ...
    
    def __init__(self, file_id, file_unique_id, thumb=..., file_name=..., mime_type=..., file_size=..., **kwargs) -> None:
        ...
    


class Video(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@Video | None:
        ...
    
    def __init__(self, file_id, file_unique_id, width, height, duration, thumb=..., file_name=..., mime_type=..., file_size=..., **kwargs) -> None:
        ...
    


class VideoNote(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@VideoNote | None:
        ...
    
    def __init__(self, file_id, file_unique_id, length, duration, thumb=..., file_size=..., **kwargs) -> None:
        ...
    


class Contact(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@Contact | None:
        ...
    
    def __init__(self, phone_number, first_name, last_name=..., user_id=..., vcard=..., **kwargs) -> None:
        ...
    


class Location(JsonDeserializable, JsonSerializable, Dictionaryable):
    @classmethod
    def de_json(cls, json_string): # -> Self@Location | None:
        ...
    
    def __init__(self, longitude, latitude, horizontal_accuracy=..., live_period=..., heading=..., proximity_alert_radius=..., **kwargs) -> None:
        ...
    
    def to_json(self): # -> str:
        ...
    
    def to_dict(self): # -> dict[str, float | int]:
        ...
    


class Venue(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@Venue | None:
        ...
    
    def __init__(self, location, title, address, foursquare_id=..., foursquare_type=..., google_place_id=..., google_place_type=..., **kwargs) -> None:
        ...
    


class UserProfilePhotos(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@UserProfilePhotos | None:
        ...
    
    def __init__(self, total_count, photos=..., **kwargs) -> None:
        ...
    


class File(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@File | None:
        ...
    
    def __init__(self, file_id, file_unique_id, file_size=..., file_path=..., **kwargs) -> None:
        ...
    


class ForceReply(JsonSerializable):
    def __init__(self, selective: Optional[bool] = ..., input_field_placeholder: Optional[str] = ...) -> None:
        ...
    
    def to_json(self): # -> str:
        ...
    


class ReplyKeyboardRemove(JsonSerializable):
    def __init__(self, selective=...) -> None:
        ...
    
    def to_json(self): # -> str:
        ...
    


class WebAppInfo(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@WebAppInfo | None:
        ...
    
    def __init__(self, url, **kwargs) -> None:
        ...
    
    def to_dict(self): # -> dict[str, str]:
        ...
    


class ReplyKeyboardMarkup(JsonSerializable):
    max_row_keys = ...
    def __init__(self, resize_keyboard: Optional[bool] = ..., one_time_keyboard: Optional[bool] = ..., selective: Optional[bool] = ..., row_width: int = ..., input_field_placeholder: Optional[str] = ...) -> None:
        ...
    
    def add(self, *args, row_width=...): # -> Self@ReplyKeyboardMarkup:
        """
        This function adds strings to the keyboard, while not exceeding row_width.
        E.g. ReplyKeyboardMarkup#add("A", "B", "C") yields the json result {keyboard: [["A"], ["B"], ["C"]]}
        when row_width is set to 1.
        When row_width is set to 2, the following is the result of this function: {keyboard: [["A", "B"], ["C"]]}
        See https://core.telegram.org/bots/api#replykeyboardmarkup

        :param args: KeyboardButton to append to the keyboard
        :param row_width: width of row
        :return: self, to allow function chaining.
        """
        ...
    
    def row(self, *args): # -> Self@ReplyKeyboardMarkup:
        """
        Adds a list of KeyboardButton to the keyboard. This function does not consider row_width.
        ReplyKeyboardMarkup#row("A")#row("B", "C")#to_json() outputs '{keyboard: [["A"], ["B", "C"]]}'
        See https://core.telegram.org/bots/api#replykeyboardmarkup

        :param args: strings
        :return: self, to allow function chaining.
        """
        ...
    
    def to_json(self): # -> str:
        """
        Converts this object to its json representation following the Telegram API guidelines described here:
        https://core.telegram.org/bots/api#replykeyboardmarkup
        :return:
        """
        ...
    


class KeyboardButtonPollType(Dictionaryable):
    def __init__(self, type=...) -> None:
        ...
    
    def to_dict(self): # -> dict[str, str]:
        ...
    


class KeyboardButton(Dictionaryable, JsonSerializable):
    def __init__(self, text: str, request_contact: Optional[bool] = ..., request_location: Optional[bool] = ..., request_poll: Optional[KeyboardButtonPollType] = ..., web_app: WebAppInfo = ...) -> None:
        ...
    
    def to_json(self): # -> str:
        ...
    
    def to_dict(self): # -> dict[str, str]:
        ...
    


class InlineKeyboardMarkup(Dictionaryable, JsonSerializable, JsonDeserializable):
    max_row_keys = ...
    @classmethod
    def de_json(cls, json_string): # -> Self@InlineKeyboardMarkup | None:
        ...
    
    def __init__(self, keyboard=..., row_width=...) -> None:
        """
        This object represents an inline keyboard that appears
        right next to the message it belongs to.
        
        :return: None
        """
        ...
    
    def add(self, *args, row_width=...): # -> Self@InlineKeyboardMarkup:
        """
        This method adds buttons to the keyboard without exceeding row_width.

        E.g. InlineKeyboardMarkup.add("A", "B", "C") yields the json result:
        {keyboard: [["A"], ["B"], ["C"]]}
        when row_width is set to 1.
        When row_width is set to 2, the result:
        {keyboard: [["A", "B"], ["C"]]}
        See https://core.telegram.org/bots/api#inlinekeyboardmarkup
        
        :param args: Array of InlineKeyboardButton to append to the keyboard
        :param row_width: width of row
        :return: self, to allow function chaining.
        """
        ...
    
    def row(self, *args): # -> Self@InlineKeyboardMarkup:
        """
        Adds a list of InlineKeyboardButton to the keyboard.
        This method does not consider row_width.

        InlineKeyboardMarkup.row("A").row("B", "C").to_json() outputs:
        '{keyboard: [["A"], ["B", "C"]]}'
        See https://core.telegram.org/bots/api#inlinekeyboardmarkup
        
        :param args: Array of InlineKeyboardButton to append to the keyboard
        :return: self, to allow function chaining.
        """
        ...
    
    def to_json(self): # -> str:
        """
        Converts this object to its json representation
        following the Telegram API guidelines described here:
        https://core.telegram.org/bots/api#inlinekeyboardmarkup
        :return:
        """
        ...
    
    def to_dict(self): # -> dict[Unknown, Unknown]:
        ...
    


class InlineKeyboardButton(Dictionaryable, JsonSerializable, JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@InlineKeyboardButton | None:
        ...
    
    def __init__(self, text, url=..., callback_data=..., web_app=..., switch_inline_query=..., switch_inline_query_current_chat=..., callback_game=..., pay=..., login_url=..., **kwargs) -> None:
        ...
    
    def to_json(self): # -> str:
        ...
    
    def to_dict(self): # -> dict[str, str]:
        ...
    


class LoginUrl(Dictionaryable, JsonSerializable, JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@LoginUrl | None:
        ...
    
    def __init__(self, url, forward_text=..., bot_username=..., request_write_access=..., **kwargs) -> None:
        ...
    
    def to_json(self): # -> str:
        ...
    
    def to_dict(self): # -> dict[str, str]:
        ...
    


class CallbackQuery(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@CallbackQuery | None:
        ...
    
    def __init__(self, id, from_user, data, chat_instance, message=..., inline_message_id=..., game_short_name=..., **kwargs) -> None:
        ...
    


class ChatPhoto(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@ChatPhoto | None:
        ...
    
    def __init__(self, small_file_id, small_file_unique_id, big_file_id, big_file_unique_id, **kwargs) -> None:
        ...
    


class ChatMember(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@ChatMember | None:
        ...
    
    def __init__(self, user, status, custom_title=..., is_anonymous=..., can_be_edited=..., can_post_messages=..., can_edit_messages=..., can_delete_messages=..., can_restrict_members=..., can_promote_members=..., can_change_info=..., can_invite_users=..., can_pin_messages=..., is_member=..., can_send_messages=..., can_send_media_messages=..., can_send_polls=..., can_send_other_messages=..., can_add_web_page_previews=..., can_manage_chat=..., can_manage_video_chats=..., until_date=..., **kwargs) -> None:
        ...
    


class ChatMemberOwner(ChatMember):
    ...


class ChatMemberAdministrator(ChatMember):
    ...


class ChatMemberMember(ChatMember):
    ...


class ChatMemberRestricted(ChatMember):
    ...


class ChatMemberLeft(ChatMember):
    ...


class ChatMemberBanned(ChatMember):
    ...


class ChatPermissions(JsonDeserializable, JsonSerializable, Dictionaryable):
    @classmethod
    def de_json(cls, json_string): # -> Self@ChatPermissions:
        ...
    
    def __init__(self, can_send_messages=..., can_send_media_messages=..., can_send_polls=..., can_send_other_messages=..., can_add_web_page_previews=..., can_change_info=..., can_invite_users=..., can_pin_messages=..., **kwargs) -> None:
        ...
    
    def to_json(self): # -> str:
        ...
    
    def to_dict(self): # -> dict[Unknown, Unknown]:
        ...
    


class BotCommand(JsonSerializable, JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@BotCommand | None:
        ...
    
    def __init__(self, command, description) -> None:
        """
        This object represents a bot command.
        :param command: Text of the command, 1-32 characters.
            Can contain only lowercase English letters, digits and underscores.
        :param description: Description of the command, 3-256 characters.
        :return:
        """
        ...
    
    def to_json(self): # -> str:
        ...
    
    def to_dict(self): # -> dict[str, str]:
        ...
    


class BotCommandScope(ABC, JsonSerializable):
    def __init__(self, type=..., chat_id=..., user_id=...) -> None:
        """
        Abstract class.
        Use BotCommandScopeX classes to set a specific scope type:
        BotCommandScopeDefault
        BotCommandScopeAllPrivateChats
        BotCommandScopeAllGroupChats
        BotCommandScopeAllChatAdministrators
        BotCommandScopeChat
        BotCommandScopeChatAdministrators
        BotCommandScopeChatMember
        """
        ...
    
    def to_json(self): # -> str:
        ...
    


class BotCommandScopeDefault(BotCommandScope):
    def __init__(self) -> None:
        """
        Represents the default scope of bot commands.
        Default commands are used if no commands with a narrower scope are specified for the user.
        """
        ...
    


class BotCommandScopeAllPrivateChats(BotCommandScope):
    def __init__(self) -> None:
        """
        Represents the scope of bot commands, covering all private chats.
        """
        ...
    


class BotCommandScopeAllGroupChats(BotCommandScope):
    def __init__(self) -> None:
        """
        Represents the scope of bot commands, covering all group and supergroup chats.
        """
        ...
    


class BotCommandScopeAllChatAdministrators(BotCommandScope):
    def __init__(self) -> None:
        """
        Represents the scope of bot commands, covering all group and supergroup chat administrators.
        """
        ...
    


class BotCommandScopeChat(BotCommandScope):
    def __init__(self, chat_id=...) -> None:
        ...
    


class BotCommandScopeChatAdministrators(BotCommandScope):
    def __init__(self, chat_id=...) -> None:
        """
        Represents the scope of bot commands, covering a specific chat.
        @param chat_id: Unique identifier for the target chat
        """
        ...
    


class BotCommandScopeChatMember(BotCommandScope):
    def __init__(self, chat_id=..., user_id=...) -> None:
        """
        Represents the scope of bot commands, covering all administrators of a specific group or supergroup chat
        @param chat_id: Unique identifier for the target chat
        @param user_id: Unique identifier of the target user
        """
        ...
    


class InlineQuery(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@InlineQuery | None:
        ...
    
    def __init__(self, id, from_user, query, offset, chat_type=..., location=..., **kwargs) -> None:
        """
        This object represents an incoming inline query.
        When the user sends an empty query, your bot could
        return some default or trending results.
        :param id: string Unique identifier for this query
        :param from_user: User Sender
        :param query: String Text of the query
        :param chat_type: String Type of the chat, from which the inline query was sent. 
            Can be either “sender” for a private chat with the inline query sender, 
            “private”, “group”, “supergroup”, or “channel”. 
        :param offset: String Offset of the results to be returned, can be controlled by the bot
        :param location: Sender location, only for bots that request user location
        :return: InlineQuery Object
        """
        ...
    


class InputTextMessageContent(Dictionaryable):
    def __init__(self, message_text, parse_mode=..., entities=..., disable_web_page_preview=...) -> None:
        ...
    
    def to_dict(self): # -> dict[str, str]:
        ...
    


class InputLocationMessageContent(Dictionaryable):
    def __init__(self, latitude, longitude, horizontal_accuracy=..., live_period=..., heading=..., proximity_alert_radius=...) -> None:
        ...
    
    def to_dict(self): # -> dict[str, float]:
        ...
    


class InputVenueMessageContent(Dictionaryable):
    def __init__(self, latitude, longitude, title, address, foursquare_id=..., foursquare_type=..., google_place_id=..., google_place_type=...) -> None:
        ...
    
    def to_dict(self): # -> dict[str, float | str]:
        ...
    


class InputContactMessageContent(Dictionaryable):
    def __init__(self, phone_number, first_name, last_name=..., vcard=...) -> None:
        ...
    
    def to_dict(self): # -> dict[str, str]:
        ...
    


class InputInvoiceMessageContent(Dictionaryable):
    def __init__(self, title, description, payload, provider_token, currency, prices, max_tip_amount=..., suggested_tip_amounts=..., provider_data=..., photo_url=..., photo_size=..., photo_width=..., photo_height=..., need_name=..., need_phone_number=..., need_email=..., need_shipping_address=..., send_phone_number_to_provider=..., send_email_to_provider=..., is_flexible=...) -> None:
        ...
    
    def to_dict(self): # -> dict[str, str | list[dict[str, str | int]]]:
        ...
    


class ChosenInlineResult(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@ChosenInlineResult | None:
        ...
    
    def __init__(self, result_id, from_user, query, location=..., inline_message_id=..., **kwargs) -> None:
        """
        This object represents a result of an inline query
        that was chosen by the user and sent to their chat partner.
        :param result_id: string The unique identifier for the result that was chosen.
        :param from_user: User The user that chose the result.
        :param query: String The query that was used to obtain the result.
        :return: ChosenInlineResult Object.
        """
        ...
    


class InlineQueryResultBase(ABC, Dictionaryable, JsonSerializable):
    def __init__(self, type, id, title=..., caption=..., input_message_content=..., reply_markup=..., caption_entities=..., parse_mode=...) -> None:
        ...
    
    def to_json(self): # -> str:
        ...
    
    def to_dict(self): # -> dict[str, Unknown]:
        ...
    


class SentWebAppMessage(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@SentWebAppMessage | None:
        ...
    
    def __init__(self, inline_message_id=...) -> None:
        ...
    
    def to_dict(self): # -> dict[Unknown, Unknown]:
        ...
    


class InlineQueryResultArticle(InlineQueryResultBase):
    def __init__(self, id, title, input_message_content, reply_markup=..., url=..., hide_url=..., description=..., thumb_url=..., thumb_width=..., thumb_height=...) -> None:
        """
        Represents a link to an article or web page.
        :param id: Unique identifier for this result, 1-64 Bytes.
        :param title: Title of the result.
        :param input_message_content: InputMessageContent : Content of the message to be sent
        :param reply_markup: InlineKeyboardMarkup : Inline keyboard attached to the message
        :param url: URL of the result.
        :param hide_url: Pass True, if you don't want the URL to be shown in the message.
        :param description: Short description of the result.
        :param thumb_url: Url of the thumbnail for the result.
        :param thumb_width: Thumbnail width.
        :param thumb_height: Thumbnail height
        :return:
        """
        ...
    
    def to_dict(self): # -> dict[str, Unknown]:
        ...
    


class InlineQueryResultPhoto(InlineQueryResultBase):
    def __init__(self, id, photo_url, thumb_url, photo_width=..., photo_height=..., title=..., description=..., caption=..., caption_entities=..., parse_mode=..., reply_markup=..., input_message_content=...) -> None:
        """
        Represents a link to a photo.
        :param id: Unique identifier for this result, 1-64 bytes
        :param photo_url: A valid URL of the photo. Photo must be in jpeg format. Photo size must not exceed 5MB
        :param thumb_url: URL of the thumbnail for the photo
        :param photo_width: Width of the photo.
        :param photo_height: Height of the photo.
        :param title: Title for the result.
        :param description: Short description of the result.
        :param caption: Caption of the photo to be sent, 0-200 characters.
        :param parse_mode: Send Markdown or HTML, if you want Telegram apps to show bold, italic, fixed-width text or
        inline URLs in the media caption.
        :param reply_markup: InlineKeyboardMarkup : Inline keyboard attached to the message
        :param input_message_content: InputMessageContent : Content of the message to be sent instead of the photo
        :return:
        """
        ...
    
    def to_dict(self): # -> dict[str, Unknown]:
        ...
    


class InlineQueryResultGif(InlineQueryResultBase):
    def __init__(self, id, gif_url, thumb_url, gif_width=..., gif_height=..., title=..., caption=..., caption_entities=..., reply_markup=..., input_message_content=..., gif_duration=..., parse_mode=..., thumb_mime_type=...) -> None:
        """
        Represents a link to an animated GIF file.
        :param id: Unique identifier for this result, 1-64 bytes.
        :param gif_url: A valid URL for the GIF file. File size must not exceed 1MB
        :param thumb_url: URL of the static thumbnail (jpeg or gif) for the result.
        :param gif_width: Width of the GIF.
        :param gif_height: Height of the GIF.
        :param title: Title for the result.
        :param caption:  Caption of the GIF file to be sent, 0-200 characters
        :param reply_markup: InlineKeyboardMarkup : Inline keyboard attached to the message
        :param input_message_content: InputMessageContent : Content of the message to be sent instead of the photo
        :return:
        """
        ...
    
    def to_dict(self): # -> dict[str, Unknown]:
        ...
    


class InlineQueryResultMpeg4Gif(InlineQueryResultBase):
    def __init__(self, id, mpeg4_url, thumb_url, mpeg4_width=..., mpeg4_height=..., title=..., caption=..., caption_entities=..., parse_mode=..., reply_markup=..., input_message_content=..., mpeg4_duration=..., thumb_mime_type=...) -> None:
        """
        Represents a link to a video animation (H.264/MPEG-4 AVC video without sound).
        :param id: Unique identifier for this result, 1-64 bytes
        :param mpeg4_url: A valid URL for the MP4 file. File size must not exceed 1MB
        :param thumb_url: URL of the static thumbnail (jpeg or gif) for the result
        :param mpeg4_width: Video width
        :param mpeg4_height: Video height
        :param title: Title for the result
        :param caption: Caption of the MPEG-4 file to be sent, 0-200 characters
        :param parse_mode: Send Markdown or HTML, if you want Telegram apps to show bold, italic, fixed-width text
        or inline URLs in the media caption.
        :param reply_markup: InlineKeyboardMarkup : Inline keyboard attached to the message
        :param input_message_content: InputMessageContent : Content of the message to be sent instead of the photo
        :return:
        """
        ...
    
    def to_dict(self): # -> dict[str, Unknown]:
        ...
    


class InlineQueryResultVideo(InlineQueryResultBase):
    def __init__(self, id, video_url, mime_type, thumb_url, title, caption=..., caption_entities=..., parse_mode=..., video_width=..., video_height=..., video_duration=..., description=..., reply_markup=..., input_message_content=...) -> None:
        """
        Represents link to a page containing an embedded video player or a video file.
        :param id: Unique identifier for this result, 1-64 bytes
        :param video_url: A valid URL for the embedded video player or video file
        :param mime_type: Mime type of the content of video url, “text/html” or “video/mp4”
        :param thumb_url: URL of the thumbnail (jpeg only) for the video
        :param title: Title for the result
        :param parse_mode: Send Markdown or HTML, if you want Telegram apps to show bold, italic, fixed-width text or
        inline URLs in the media caption.
        :param video_width: Video width
        :param video_height: Video height
        :param video_duration: Video duration in seconds
        :param description: Short description of the result
        :return:
        """
        ...
    
    def to_dict(self): # -> dict[str, Unknown]:
        ...
    


class InlineQueryResultAudio(InlineQueryResultBase):
    def __init__(self, id, audio_url, title, caption=..., caption_entities=..., parse_mode=..., performer=..., audio_duration=..., reply_markup=..., input_message_content=...) -> None:
        ...
    
    def to_dict(self): # -> dict[str, Unknown]:
        ...
    


class InlineQueryResultVoice(InlineQueryResultBase):
    def __init__(self, id, voice_url, title, caption=..., caption_entities=..., parse_mode=..., voice_duration=..., reply_markup=..., input_message_content=...) -> None:
        ...
    
    def to_dict(self): # -> dict[str, Unknown]:
        ...
    


class InlineQueryResultDocument(InlineQueryResultBase):
    def __init__(self, id, title, document_url, mime_type, caption=..., caption_entities=..., parse_mode=..., description=..., reply_markup=..., input_message_content=..., thumb_url=..., thumb_width=..., thumb_height=...) -> None:
        ...
    
    def to_dict(self): # -> dict[str, Unknown]:
        ...
    


class InlineQueryResultLocation(InlineQueryResultBase):
    def __init__(self, id, title, latitude, longitude, horizontal_accuracy, live_period=..., reply_markup=..., input_message_content=..., thumb_url=..., thumb_width=..., thumb_height=..., heading=..., proximity_alert_radius=...) -> None:
        ...
    
    def to_dict(self): # -> dict[str, Unknown]:
        ...
    


class InlineQueryResultVenue(InlineQueryResultBase):
    def __init__(self, id, title, latitude, longitude, address, foursquare_id=..., foursquare_type=..., reply_markup=..., input_message_content=..., thumb_url=..., thumb_width=..., thumb_height=..., google_place_id=..., google_place_type=...) -> None:
        ...
    
    def to_dict(self): # -> dict[str, Unknown]:
        ...
    


class InlineQueryResultContact(InlineQueryResultBase):
    def __init__(self, id, phone_number, first_name, last_name=..., vcard=..., reply_markup=..., input_message_content=..., thumb_url=..., thumb_width=..., thumb_height=...) -> None:
        ...
    
    def to_dict(self): # -> dict[str, Unknown]:
        ...
    


class InlineQueryResultGame(InlineQueryResultBase):
    def __init__(self, id, game_short_name, reply_markup=...) -> None:
        ...
    
    def to_dict(self): # -> dict[str, Unknown]:
        ...
    


class InlineQueryResultCachedBase(ABC, JsonSerializable):
    def __init__(self) -> None:
        ...
    
    def to_json(self): # -> str:
        ...
    


class InlineQueryResultCachedPhoto(InlineQueryResultCachedBase):
    def __init__(self, id, photo_file_id, title=..., description=..., caption=..., caption_entities=..., parse_mode=..., reply_markup=..., input_message_content=...) -> None:
        ...
    


class InlineQueryResultCachedGif(InlineQueryResultCachedBase):
    def __init__(self, id, gif_file_id, title=..., description=..., caption=..., caption_entities=..., parse_mode=..., reply_markup=..., input_message_content=...) -> None:
        ...
    


class InlineQueryResultCachedMpeg4Gif(InlineQueryResultCachedBase):
    def __init__(self, id, mpeg4_file_id, title=..., description=..., caption=..., caption_entities=..., parse_mode=..., reply_markup=..., input_message_content=...) -> None:
        ...
    


class InlineQueryResultCachedSticker(InlineQueryResultCachedBase):
    def __init__(self, id, sticker_file_id, reply_markup=..., input_message_content=...) -> None:
        ...
    


class InlineQueryResultCachedDocument(InlineQueryResultCachedBase):
    def __init__(self, id, document_file_id, title, description=..., caption=..., caption_entities=..., parse_mode=..., reply_markup=..., input_message_content=...) -> None:
        ...
    


class InlineQueryResultCachedVideo(InlineQueryResultCachedBase):
    def __init__(self, id, video_file_id, title, description=..., caption=..., caption_entities=..., parse_mode=..., reply_markup=..., input_message_content=...) -> None:
        ...
    


class InlineQueryResultCachedVoice(InlineQueryResultCachedBase):
    def __init__(self, id, voice_file_id, title, caption=..., caption_entities=..., parse_mode=..., reply_markup=..., input_message_content=...) -> None:
        ...
    


class InlineQueryResultCachedAudio(InlineQueryResultCachedBase):
    def __init__(self, id, audio_file_id, caption=..., caption_entities=..., parse_mode=..., reply_markup=..., input_message_content=...) -> None:
        ...
    


class Game(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@Game | None:
        ...
    
    @classmethod
    def parse_photo(cls, photo_size_array): # -> list[Unknown]:
        ...
    
    @classmethod
    def parse_entities(cls, message_entity_array): # -> list[Unknown]:
        ...
    
    def __init__(self, title, description, photo, text=..., text_entities=..., animation=..., **kwargs) -> None:
        ...
    


class Animation(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@Animation | None:
        ...
    
    def __init__(self, file_id, file_unique_id, width=..., height=..., duration=..., thumb=..., file_name=..., mime_type=..., file_size=..., **kwargs) -> None:
        ...
    


class GameHighScore(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@GameHighScore | None:
        ...
    
    def __init__(self, position, user, score, **kwargs) -> None:
        ...
    


class LabeledPrice(JsonSerializable):
    def __init__(self, label, amount) -> None:
        ...
    
    def to_dict(self): # -> dict[str, str | int]:
        ...
    
    def to_json(self): # -> str:
        ...
    


class Invoice(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@Invoice | None:
        ...
    
    def __init__(self, title, description, start_parameter, currency, total_amount, **kwargs) -> None:
        ...
    


class ShippingAddress(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@ShippingAddress | None:
        ...
    
    def __init__(self, country_code, state, city, street_line1, street_line2, post_code, **kwargs) -> None:
        ...
    


class OrderInfo(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@OrderInfo | None:
        ...
    
    def __init__(self, name=..., phone_number=..., email=..., shipping_address=..., **kwargs) -> None:
        ...
    


class ShippingOption(JsonSerializable):
    def __init__(self, id, title) -> None:
        ...
    
    def add_price(self, *args): # -> Self@ShippingOption:
        """
        Add LabeledPrice to ShippingOption
        
        :param args: LabeledPrices
        """
        ...
    
    def to_json(self): # -> str:
        ...
    


class SuccessfulPayment(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@SuccessfulPayment | None:
        ...
    
    def __init__(self, currency, total_amount, invoice_payload, shipping_option_id=..., order_info=..., telegram_payment_charge_id=..., provider_payment_charge_id=..., **kwargs) -> None:
        ...
    


class ShippingQuery(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@ShippingQuery | None:
        ...
    
    def __init__(self, id, from_user, invoice_payload, shipping_address, **kwargs) -> None:
        ...
    


class PreCheckoutQuery(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@PreCheckoutQuery | None:
        ...
    
    def __init__(self, id, from_user, currency, total_amount, invoice_payload, shipping_option_id=..., order_info=..., **kwargs) -> None:
        ...
    


class StickerSet(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@StickerSet | None:
        ...
    
    def __init__(self, name, title, is_animated, is_video, contains_masks, stickers, thumb=..., **kwargs) -> None:
        ...
    


class Sticker(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@Sticker | None:
        ...
    
    def __init__(self, file_id, file_unique_id, width, height, is_animated, is_video, thumb=..., emoji=..., set_name=..., mask_position=..., file_size=..., premium_animation=..., **kwargs) -> None:
        ...
    


class MaskPosition(Dictionaryable, JsonDeserializable, JsonSerializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@MaskPosition | None:
        ...
    
    def __init__(self, point, x_shift, y_shift, scale, **kwargs) -> None:
        ...
    
    def to_json(self): # -> str:
        ...
    
    def to_dict(self): # -> dict[str, str | float]:
        ...
    


class InputMedia(Dictionaryable, JsonSerializable):
    def __init__(self, type, media, caption=..., parse_mode=..., caption_entities=...) -> None:
        ...
    
    def to_json(self): # -> str:
        ...
    
    def to_dict(self): # -> dict[str, str]:
        ...
    
    def convert_input_media(self): # -> tuple[str, None] | tuple[str, dict[str | Unknown, str]]:
        ...
    


class InputMediaPhoto(InputMedia):
    def __init__(self, media, caption=..., parse_mode=...) -> None:
        ...
    
    def to_dict(self): # -> dict[str, str]:
        ...
    


class InputMediaVideo(InputMedia):
    def __init__(self, media, thumb=..., caption=..., parse_mode=..., width=..., height=..., duration=..., supports_streaming=...) -> None:
        ...
    
    def to_dict(self): # -> dict[str, str]:
        ...
    


class InputMediaAnimation(InputMedia):
    def __init__(self, media, thumb=..., caption=..., parse_mode=..., width=..., height=..., duration=...) -> None:
        ...
    
    def to_dict(self): # -> dict[str, str]:
        ...
    


class InputMediaAudio(InputMedia):
    def __init__(self, media, thumb=..., caption=..., parse_mode=..., duration=..., performer=..., title=...) -> None:
        ...
    
    def to_dict(self): # -> dict[str, str]:
        ...
    


class InputMediaDocument(InputMedia):
    def __init__(self, media, thumb=..., caption=..., parse_mode=..., disable_content_type_detection=...) -> None:
        ...
    
    def to_dict(self): # -> dict[str, str]:
        ...
    


class PollOption(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@PollOption | None:
        ...
    
    def __init__(self, text, voter_count=..., **kwargs) -> None:
        ...
    


class Poll(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@Poll | None:
        ...
    
    def __init__(self, question, options, poll_id=..., total_voter_count=..., is_closed=..., is_anonymous=..., type=..., allows_multiple_answers=..., correct_option_id=..., explanation=..., explanation_entities=..., open_period=..., close_date=..., poll_type=..., **kwargs) -> None:
        ...
    
    def add(self, option): # -> None:
        ...
    


class PollAnswer(JsonSerializable, JsonDeserializable, Dictionaryable):
    @classmethod
    def de_json(cls, json_string): # -> Self@PollAnswer | None:
        ...
    
    def __init__(self, poll_id, user, option_ids, **kwargs) -> None:
        ...
    
    def to_json(self): # -> str:
        ...
    
    def to_dict(self): # -> dict[str, str | dict[str, int | bool | str] | List[int]]:
        ...
    


class ChatLocation(JsonSerializable, JsonDeserializable, Dictionaryable):
    @classmethod
    def de_json(cls, json_string): # -> Self@ChatLocation:
        ...
    
    def __init__(self, location, address, **kwargs) -> None:
        ...
    
    def to_json(self): # -> str:
        ...
    
    def to_dict(self): # -> dict[str, dict[str, float | int] | str]:
        ...
    


class ChatInviteLink(JsonSerializable, JsonDeserializable, Dictionaryable):
    @classmethod
    def de_json(cls, json_string): # -> Self@ChatInviteLink | None:
        ...
    
    def __init__(self, invite_link, creator, creates_join_request, is_primary, is_revoked, name=..., expire_date=..., member_limit=..., pending_join_request_count=..., **kwargs) -> None:
        ...
    
    def to_json(self): # -> str:
        ...
    
    def to_dict(self): # -> dict[str, str | dict[str, int | bool | str] | bool]:
        ...
    


class ProximityAlertTriggered(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@ProximityAlertTriggered | None:
        ...
    
    def __init__(self, traveler, watcher, distance, **kwargs) -> None:
        ...
    


class VideoChatStarted(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@VideoChatStarted:
        ...
    
    def __init__(self) -> None:
        """
        This object represents a service message about a voice chat started in the chat. 
        Currently holds no information.
        """
        ...
    


class VoiceChatStarted(VideoChatStarted):
    def __init__(self) -> None:
        ...
    


class VideoChatScheduled(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@VideoChatScheduled | None:
        ...
    
    def __init__(self, start_date, **kwargs) -> None:
        ...
    


class VoiceChatScheduled(VideoChatScheduled):
    def __init__(self, *args, **kwargs) -> None:
        ...
    


class VideoChatEnded(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@VideoChatEnded | None:
        ...
    
    def __init__(self, duration, **kwargs) -> None:
        ...
    


class VoiceChatEnded(VideoChatEnded):
    def __init__(self, *args, **kwargs) -> None:
        ...
    


class VideoChatParticipantsInvited(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@VideoChatParticipantsInvited | None:
        ...
    
    def __init__(self, users=..., **kwargs) -> None:
        ...
    


class VoiceChatParticipantsInvited(VideoChatParticipantsInvited):
    def __init__(self, *args, **kwargs) -> None:
        ...
    


class MessageAutoDeleteTimerChanged(JsonDeserializable):
    @classmethod
    def de_json(cls, json_string): # -> Self@MessageAutoDeleteTimerChanged | None:
        ...
    
    def __init__(self, message_auto_delete_time, **kwargs) -> None:
        ...
    


class MenuButton(JsonDeserializable, JsonSerializable):
    """
    Base class for MenuButtons.
    """
    @classmethod
    def de_json(cls, json_string): # -> MenuButtonCommands | MenuButtonWebApp | MenuButtonDefault | None:
        ...
    
    def to_json(self):
        ...
    


class MenuButtonCommands(MenuButton):
    def __init__(self, type) -> None:
        ...
    
    def to_dict(self): # -> dict[str, Unknown]:
        ...
    
    def to_json(self): # -> str:
        ...
    


class MenuButtonWebApp(MenuButton):
    def __init__(self, type, text, web_app) -> None:
        ...
    
    def to_dict(self): # -> dict[str, str | dict[str, str]]:
        ...
    
    def to_json(self): # -> str:
        ...
    


class MenuButtonDefault(MenuButton):
    def __init__(self, type) -> None:
        ...
    
    def to_dict(self): # -> dict[str, str]:
        ...
    
    def to_json(self): # -> str:
        ...
    


class ChatAdministratorRights(JsonDeserializable, JsonSerializable):
    """
    Class representation of:
    https://core.telegram.org/bots/api#chatadministratorrights
    """
    @classmethod
    def de_json(cls, json_string): # -> Self@ChatAdministratorRights | None:
        ...
    
    def __init__(self, is_anonymous: bool, can_manage_chat: bool, can_delete_messages: bool, can_manage_video_chats: bool, can_restrict_members: bool, can_promote_members: bool, can_change_info: bool, can_invite_users: bool, can_post_messages: bool = ..., can_edit_messages: bool = ..., can_pin_messages: bool = ...) -> None:
        ...
    
    def to_dict(self): # -> dict[str, bool]:
        ...
    
    def to_json(self): # -> str:
        ...
    


