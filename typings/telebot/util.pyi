"""
This type stub file was generated by pyright.
"""

import threading
from typing import Any, Callable, Dict, List, Optional, Union
from telebot import types

MAX_MESSAGE_LENGTH = ...
logger = ...
thread_local = ...
content_type_media = ...
content_type_service = ...
update_types = ...
class WorkerThread(threading.Thread):
    count = ...
    def __init__(self, exception_callback=..., queue=..., name=...) -> None:
        ...
    
    def run(self): # -> None:
        ...
    
    def put(self, task, *args, **kwargs): # -> None:
        ...
    
    def raise_exceptions(self): # -> None:
        ...
    
    def clear_exceptions(self): # -> None:
        ...
    
    def stop(self): # -> None:
        ...
    


class ThreadPool:
    def __init__(self, telebot, num_threads=...) -> None:
        ...
    
    def put(self, func, *args, **kwargs): # -> None:
        ...
    
    def on_exception(self, worker_thread, exc_info): # -> None:
        ...
    
    def raise_exceptions(self): # -> None:
        ...
    
    def clear_exceptions(self): # -> None:
        ...
    
    def close(self): # -> None:
        ...
    


class AsyncTask:
    def __init__(self, target, *args, **kwargs) -> None:
        ...
    
    def wait(self):
        ...
    


class CustomRequestResponse:
    def __init__(self, json_text, status_code=..., reason=...) -> None:
        ...
    
    def json(self): # -> Any:
        ...
    


def async_dec(): # -> (fn: Unknown) -> ((*args: Unknown, **kwargs: Unknown) -> AsyncTask):
    ...

def is_string(var): # -> bool:
    ...

def is_dict(var): # -> bool:
    ...

def is_bytes(var): # -> bool:
    ...

def is_pil_image(var): # -> bool:
    ...

def pil_image_to_file(image, extension=..., quality=...): # -> BytesIO:
    ...

def is_command(text: str) -> bool:
    r"""
    Checks if `text` is a command. Telegram chat commands start with the '/' character.
    
    :param text: Text to check.
    :return: True if `text` is a command, else False.
    """
    ...

def extract_command(text: str) -> Union[str, None]:
    """
    Extracts the command from `text` (minus the '/') if `text` is a command (see is_command).
    If `text` is not a command, this function returns None.

    Examples:
    extract_command('/help'): 'help'
    extract_command('/help@BotName'): 'help'
    extract_command('/search black eyed peas'): 'search'
    extract_command('Good day to you'): None

    :param text: String to extract the command from
    :return: the command if `text` is a command (according to is_command), else None.
    """
    ...

def extract_arguments(text: str) -> str:
    """
    Returns the argument after the command.
    
    Examples:
    extract_arguments("/get name"): 'name'
    extract_arguments("/get"): ''
    extract_arguments("/get@botName name"): 'name'
    
    :param text: String to extract the arguments from a command
    :return: the arguments if `text` is a command (according to is_command), else None.
    """
    ...

def split_string(text: str, chars_per_string: int) -> List[str]:
    """
    Splits one string into multiple strings, with a maximum amount of `chars_per_string` characters per string.
    This is very useful for splitting one giant message into multiples.

    :param text: The text to split
    :param chars_per_string: The number of characters per line the text is split into.
    :return: The splitted text as a list of strings.
    """
    ...

def smart_split(text: str, chars_per_string: int = ...) -> List[str]:
    r"""
    Splits one string into multiple strings, with a maximum amount of `chars_per_string` characters per string.
    This is very useful for splitting one giant message into multiples.
    If `chars_per_string` > 4096: `chars_per_string` = 4096.
    Splits by '\n', '. ' or ' ' in exactly this priority.

    :param text: The text to split
    :param chars_per_string: The number of maximum characters per part the text is split to.
    :return: The splitted text as a list of strings.
    """
    ...

def escape(text: str) -> str:
    """
    Replaces the following chars in `text` ('&' with '&amp;', '<' with '&lt;' and '>' with '&gt;').

    :param text: the text to escape
    :return: the escaped text
    """
    ...

def user_link(user: types.User, include_id: bool = ...) -> str:
    """
    Returns an HTML user link. This is useful for reports.
    Attention: Don't forget to set parse_mode to 'HTML'!

    Example:
    bot.send_message(your_user_id, user_link(message.from_user) + ' started the bot!', parse_mode='HTML')

    :param user: the user (not the user_id)
    :param include_id: include the user_id
    :return: HTML user link
    """
    ...

def quick_markup(values: Dict[str, Dict[str, Any]], row_width: int = ...) -> types.InlineKeyboardMarkup:
    """
    Returns a reply markup from a dict in this format: {'text': kwargs}
    This is useful to avoid always typing 'btn1 = InlineKeyboardButton(...)' 'btn2 = InlineKeyboardButton(...)' 
    
    Example:

    .. code-block:: python

        quick_markup({
            'Twitter': {'url': 'https://twitter.com'},
            'Facebook': {'url': 'https://facebook.com'},
            'Back': {'callback_data': 'whatever'}
        }, row_width=2): 
            # returns an InlineKeyboardMarkup with two buttons in a row, one leading to Twitter, the other to facebook
            # and a back button below

        # kwargs can be: 
        {
            'url': None, 
            'callback_data': None, 
            'switch_inline_query': None,
            'switch_inline_query_current_chat': None,
            'callback_game': None,
            'pay': None,
            'login_url': None,
            'web_app': None
        }
    
    :param values: a dict containing all buttons to create in this format: {text: kwargs} {str:}
    :param row_width: int row width
    :return: InlineKeyboardMarkup
    """
    ...

def or_set(self): # -> None:
    ...

def or_clear(self): # -> None:
    ...

def orify(e, changed_callback): # -> None:
    ...

def OrEvent(*events): # -> Event:
    ...

def per_thread(key, construct_value, reset=...): # -> Any:
    ...

def chunks(lst, n): # -> Generator[Unknown, None, None]:
    """Yield successive n-sized chunks from lst."""
    ...

def generate_random_token(): # -> str:
    ...

def deprecated(warn: bool = ..., alternative: Optional[Callable] = ..., deprecation_text=...): # -> (function: Unknown) -> ((*args: Unknown, **kwargs: Unknown) -> Unknown):
    """
    Use this decorator to mark functions as deprecated.
    When the function is used, an info (or warning if `warn` is True) is logged.
    
    :param warn: If True a warning is logged else an info
    :param alternative: The new function to use instead
    :param deprecation_text: Custom deprecation text
    """
    ...

def webhook_google_functions(bot, request): # -> tuple[Literal['Bot FAIL'], Literal[400]] | Literal['', 'Bot ON']:
    """A webhook endpoint for Google Cloud Functions FaaS."""
    ...

def antiflood(function, *args, **kwargs): # -> None:
    """
    Use this function inside loops in order to avoid getting TooManyRequests error.
    Example:
    
    .. code-block:: python3
    
        from telebot.util import antiflood
        for chat_id in chat_id_list:
        msg = antiflood(bot.send_message, chat_id, text)
        
    :param function:
    :param args:
    :param kwargs:
    :return: None
    """
    ...

def parse_web_app_data(token: str, raw_init_data: str): # -> dict[Unknown, Unknown] | Literal[False]:
    ...

def validate_web_app_data(token, raw_init_data): # -> Literal[False]:
    ...

